"""
Fix per AntivirusCheck - src/agid_assessment_methodology/checks/malware/antivirus.py

Aggiorna l'implementazione per essere compatibile con i test
"""

import os
import platform
import subprocess
import logging
import json
from typing import Dict, Any, List, Optional
from datetime import datetime

from ..base import BaseCheck, CheckResult, CheckStatus
from ...utils.helpers import run_command, is_windows, is_linux

logger = logging.getLogger(__name__)


class AntivirusCheck(BaseCheck):
    """Check for active antivirus protection on the system."""

    def __init__(self):
        super().__init__()
        self.id = "antivirus"
        self.name = "Antivirus Protection"
        self.description = "Verifies that antivirus software is installed and running"
        self.category = "malware"
        self.severity = "critical"
        self.supported_os = ["windows", "linux", "macos"]

    def execute(self, context: Dict[str, Any]) -> CheckResult:
        """
        Execute antivirus check based on operating system.

        Args:
            context: Execution context with system information

        Returns:
            CheckResult with antivirus status details
        """
        try:
            os_type = context.get('os_type', platform.system().lower())

            if os_type == 'windows':
                return self._check_windows_antivirus()
            elif os_type == 'linux':
                return self._check_linux_antivirus()
            elif os_type == 'darwin':
                return self._check_macos_antivirus()
            else:
                return CheckResult(
                    status=CheckStatus.ERROR,
                    message=f"Unsupported OS: {os_type}",
                    details={"error": f"Unsupported OS: {os_type}"}
                )

        except Exception as e:
            logger.error(f"Error in antivirus check: {str(e)}")
            return CheckResult(
                status=CheckStatus.ERROR,
                message=f"Error executing antivirus check: {str(e)}",
                details={"error": str(e)}
            )

    def _check_windows_antivirus(self) -> CheckResult:
        """Check Windows antivirus status using WMI and PowerShell."""
        details = {
            "defender_status": "unknown",
            "third_party_av": [],
            "active_protection": False,
            "real_time_protection": False
        }

        issues = []
        recommendations = []

        try:
            # Check Windows Defender status first
            defender_status = self._check_windows_defender()
            if defender_status:
                details.update(defender_status)
                details["active_protection"] = defender_status.get("enabled", False)
                details["real_time_protection"] = defender_status.get("real_time_enabled", False)
                details["defender_status"] = "enabled" if defender_status.get("enabled") else "disabled"
            else:
                # Se non riusciamo a controllare Defender, assumiamo sia disabilitato
                details["defender_status"] = "disabled"

            # Check third-party antivirus products via WMI
            third_party_av = self._check_third_party_antivirus_windows()
            if third_party_av:
                details["third_party_av"] = third_party_av
                # If any third-party AV is active, mark as protected
                if any(av.get("status") == "active" for av in third_party_av):
                    details["active_protection"] = True

            # Generate issues and recommendations
            if not details["real_time_protection"]:
                issues.append({
                    "severity": "high",
                    "description": "Real-time protection is disabled"
                })

            if not details["active_protection"]:
                issues.append({
                    "severity": "critical",
                    "description": "No active antivirus protection found"
                })
                recommendations.append("Install and enable antivirus software")

            # Determine overall status
            if details["active_protection"]:
                status = CheckStatus.PASS
                message = "Antivirus protection is active and properly configured"
            else:
                status = CheckStatus.FAIL
                message = "No active antivirus protection found"

        except Exception as e:
            logger.error(f"Error checking Windows antivirus: {str(e)}")
            status = CheckStatus.FAIL
            details["error"] = str(e)
            message = f"Error checking antivirus status: {str(e)}"

        return CheckResult(
            status=status,
            message=message,
            details=details,
            issues=issues,
            recommendations=recommendations
        )

    def _check_windows_defender(self) -> Optional[Dict[str, Any]]:
        """Check Windows Defender status using PowerShell."""
        try:
            # PowerShell command to get Windows Defender status
            cmd = [
                "powershell", "-Command",
                "Get-MpComputerStatus | Select-Object AntivirusEnabled, RealTimeProtectionEnabled, "
                "OnAccessProtectionEnabled, NISEnabled, AntivirusSignatureLastUpdated | ConvertTo-Json"
            ]

            result = run_command(cmd, timeout=30)
            if result and result.get("returncode") == 0:
                defender_info = json.loads(result["stdout"])

                return {
                    "name": "Windows Defender",
                    "enabled": defender_info.get("AntivirusEnabled", False),
                    "real_time_enabled": defender_info.get("RealTimeProtectionEnabled", False),
                    "on_access_protection": defender_info.get("OnAccessProtectionEnabled", False),
                    "nis_enabled": defender_info.get("NISEnabled", False),
                    "last_signature_update": defender_info.get("AntivirusSignatureLastUpdated")
                }
        except Exception as e:
            logger.warning(f"Could not check Windows Defender status: {str(e)}")

        return None

    def _check_third_party_antivirus_windows(self) -> List[Dict[str, Any]]:
        """Check for third-party antivirus products using WMI."""
        products = []

        try:
            # Check AntiVirusProduct WMI class
            cmd = [
                "powershell", "-Command",
                "Get-WmiObject -Namespace 'root\\SecurityCenter2' -Class AntiVirusProduct | "
                "Select-Object displayName, productState, pathToSignedProductExe | ConvertTo-Json"
            ]

            result = run_command(cmd, timeout=30)
            if result and result.get("returncode") == 0 and result["stdout"].strip():
                av_products = json.loads(result["stdout"])

                # Handle single product vs array
                if isinstance(av_products, dict):
                    av_products = [av_products]

                for product in av_products:
                    # Decode product state (hex value that indicates status)
                    product_state = product.get("productState", 0)

                    products.append({
                        "name": product.get("displayName", "Unknown"),
                        "path": product.get("pathToSignedProductExe", ""),
                        "status": self._decode_av_state(product_state),
                        "raw_state": hex(product_state) if product_state else "0x0"
                    })

        except Exception as e:
            logger.warning(f"Could not check third-party antivirus: {str(e)}")

        return products

    def _decode_av_state(self, state: int) -> str:
        """Decode antivirus product state from hex value."""
        try:
            # Convert string hex to int if needed
            if isinstance(state, str):
                if state.startswith('0x'):
                    state = int(state, 16)
                else:
                    state = int(state)

            # Common state values (this is a simplified interpretation)
            if state == 0:
                return "disabled"
            elif state & 0x1000:  # Real-time protection enabled
                return "active"
            elif state & 0x0010:  # Product enabled
                return "active"
            else:
                return "unknown"
        except:
            return "unknown"

    def _check_linux_antivirus(self) -> CheckResult:
        """Check Linux antivirus status (primarily ClamAV)."""
        details = {
            "clamav_installed": False,
            "clamav_running": False,
            "clamd_running": False,
            "other_av": [],
            "active_protection": False
        }

        issues = []
        recommendations = []

        try:
            # Check if ClamAV is installed
            clamav_info = self._check_clamav_linux()
            if clamav_info:
                details.update(clamav_info)
                details["active_protection"] = clamav_info["clamd_running"]

            # Check for other common Linux antivirus solutions
            other_av = self._check_other_linux_antivirus()
            if other_av:
                details["other_av"] = other_av
                if any(av.get("running", False) for av in other_av):
                    details["active_protection"] = True

            # Generate issues and recommendations
            if not details["clamav_installed"] and not details["other_av"]:
                issues.append({
                    "severity": "high",
                    "description": "No antivirus software detected"
                })
                recommendations.append("Consider installing ClamAV or other antivirus solution")

            # Determine status
            if details["active_protection"]:
                status = CheckStatus.PASS
                message = "Antivirus protection is active"
            elif details["clamav_installed"] or details["other_av"]:
                status = CheckStatus.WARNING
                message = "Antivirus software is installed but may not be running"
                recommendations.append("Check service status and start antivirus daemon")
            else:
                status = CheckStatus.FAIL
                message = "No antivirus software detected"

        except Exception as e:
            logger.error(f"Error checking Linux antivirus: {str(e)}")
            status = CheckStatus.ERROR
            details["error"] = str(e)
            message = f"Error checking antivirus status: {str(e)}"

        return CheckResult(
            status=status,
            message=message,
            details=details,
            issues=issues,
            recommendations=recommendations
        )

    def _check_clamav_linux(self) -> Optional[Dict[str, Any]]:
        """Check ClamAV installation and status on Linux."""
        clamav_info = {
            "clamav_installed": False,
            "clamav_running": False,
            "clamd_running": False,
            "version": None
        }

        try:
            # Check if clamscan is installed
            result = run_command(["which", "clamscan"], timeout=10)
            if result and result.get("returncode") == 0:
                clamav_info["clamav_installed"] = True

                # Get ClamAV version
                version_result = run_command(["clamscan", "--version"], timeout=10)
                if version_result and version_result.get("returncode") == 0:
                    clamav_info["version"] = version_result["stdout"].strip()

            # Check if clamd daemon is running
            daemon_result = run_command(["pgrep", "-x", "clamd"], timeout=10)
            if daemon_result and daemon_result.get("returncode") == 0:
                clamav_info["clamd_running"] = True

            # Alternative check for clamd service
            service_result = run_command(["systemctl", "is-active", "clamav-daemon"], timeout=10)
            if service_result and service_result.get("returncode") == 0:
                if "active" in service_result["stdout"]:
                    clamav_info["clamd_running"] = True

        except Exception as e:
            logger.warning(f"Error checking ClamAV: {str(e)}")

        return clamav_info if clamav_info["clamav_installed"] else None

    def _check_other_linux_antivirus(self) -> List[Dict[str, Any]]:
        """Check for other Linux antivirus solutions."""
        products = []

        # List of common Linux antivirus solutions to check
        av_solutions = [
            {"name": "Sophos", "process": "savd", "command": "savscan"},
            {"name": "ESET", "process": "esets_daemon", "command": "esets_scan"},
            {"name": "Bitdefender", "process": "bdsec", "command": "bdscan"},
            {"name": "Kaspersky", "process": "kesl", "command": "kesl-control"},
            {"name": "F-Secure", "process": "fsav", "command": "fsav"}
        ]

        for av in av_solutions:
            try:
                # Check if process is running
                proc_result = run_command(["pgrep", "-x", av["process"]], timeout=10)
                process_running = proc_result and proc_result.get("returncode") == 0

                # Check if command exists
                cmd_result = run_command(["which", av["command"]], timeout=10)
                command_exists = cmd_result and cmd_result.get("returncode") == 0

                if process_running or command_exists:
                    products.append({
                        "name": av["name"],
                        "running": process_running,
                        "installed": command_exists
                    })

            except Exception as e:
                logger.debug(f"Error checking {av['name']}: {str(e)}")

        return products

    def _check_macos_antivirus(self) -> CheckResult:
        """Check macOS antivirus status."""
        details = {
            "xprotect_enabled": False,
            "gatekeeper_enabled": False,
            "third_party_av": [],
            "active_protection": False
        }

        issues = []
        recommendations = []

        try:
            # Check XProtect (built-in macOS antivirus)
            xprotect_info = self._check_xprotect_macos()
            if xprotect_info:
                details["xprotect_enabled"] = xprotect_info.get("enabled", False)
                if details["xprotect_enabled"]:
                    details["active_protection"] = True

            # Check Gatekeeper
            gatekeeper_info = self._check_gatekeeper_macos()
            if gatekeeper_info:
                details["gatekeeper_enabled"] = gatekeeper_info.get("enabled", False)

            # Check for third-party macOS antivirus
            third_party_av = self._check_third_party_antivirus_macos()
            if third_party_av:
                details["third_party_av"] = third_party_av
                if any(av.get("running", False) for av in third_party_av):
                    details["active_protection"] = True

            # Determine status
            if details["active_protection"] or details["gatekeeper_enabled"]:
                status = CheckStatus.PASS
                message = "Antivirus protection is active"
            else:
                status = CheckStatus.WARNING
                message = "Limited antivirus protection"
                recommendations.append("Consider installing additional antivirus software")

        except Exception as e:
            logger.error(f"Error checking macOS antivirus: {str(e)}")
            status = CheckStatus.ERROR
            details["error"] = str(e)
            message = f"Error checking antivirus status: {str(e)}"

        return CheckResult(
            status=status,
            message=message,
            details=details,
            issues=issues,
            recommendations=recommendations
        )

    def _check_xprotect_macos(self) -> Optional[Dict[str, Any]]:
        """Check XProtect status on macOS."""
        try:
            # Check if XProtect service is running
            result = run_command(["ps", "aux"], timeout=10)
            if result and result.get("returncode") == 0:
                xprotect_running = "XProtect" in result["stdout"]
                return {"enabled": xprotect_running}
        except Exception as e:
            logger.warning(f"Could not check XProtect status: {str(e)}")

        return None

    def _check_gatekeeper_macos(self) -> Optional[Dict[str, Any]]:
        """Check Gatekeeper status on macOS."""
        try:
            result = run_command(["spctl", "--status"], timeout=10)
            if result and result.get("returncode") == 0:
                enabled = "assessments enabled" in result["stdout"]
                return {"enabled": enabled}
        except Exception as e:
            logger.warning(f"Could not check Gatekeeper status: {str(e)}")

        return None

    def _check_third_party_antivirus_macos(self) -> List[Dict[str, Any]]:
        """Check for third-party antivirus on macOS."""
        products = []

        # Common macOS antivirus solutions
        av_solutions = [
            {"name": "Norton", "process": "Norton", "path": "/Applications/Norton Security.app"},
            {"name": "McAfee", "process": "McAfee", "path": "/Applications/McAfee Security.app"},
            {"name": "Bitdefender", "process": "Bitdefender", "path": "/Applications/Bitdefender Antivirus.app"},
            {"name": "Kaspersky", "process": "Kaspersky", "path": "/Applications/Kaspersky Security Cloud.app"},
            {"name": "Sophos", "process": "Sophos", "path": "/Applications/Sophos Home.app"}
        ]

        for av in av_solutions:
            try:
                # Check if application is installed
                installed = os.path.exists(av["path"])

                # Check if process is running
                proc_result = run_command(["pgrep", "-i", av["process"]], timeout=10)
                running = proc_result and proc_result.get("returncode") == 0

                if installed or running:
                    products.append({
                        "name": av["name"],
                        "installed": installed,
                        "running": running
                    })

            except Exception as e:
                logger.debug(f"Error checking {av['name']}: {str(e)}")

        return products

    # Metodi helper per i test
    def _get_windows_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate Windows-specific recommendations."""
        recommendations = []

        if results.get("defender_status") == "disabled" and not results.get("third_party_av"):
            recommendations.append("Install and enable antivirus software")

        if not results.get("real_time_protection"):
            recommendations.append("Enable real-time protection")

        return recommendations

    def _get_linux_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate Linux-specific recommendations."""
        recommendations = []

        if not results.get("clamav_installed") and not results.get("other_av"):
            recommendations.append("Consider installing ClamAV antivirus")

        return recommendations

    # Metodi mancanti che i test stanno cercando (per compatibilità)
    def _get_windows_process_name(self, pid: str) -> str:
        """Get process name from PID on Windows."""
        try:
            ps_command = f"""
            Get-Process -Id {pid} -ErrorAction SilentlyContinue | 
            Select-Object -Property ProcessName | 
            ConvertTo-Json
            """

            result = subprocess.run(
                ["powershell", "-Command", ps_command],
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode == 0 and result.stdout.strip():
                process_data = json.loads(result.stdout)
                return process_data.get('ProcessName', 'Unknown')

            return f"Unknown ({pid})"

        except Exception:
            return f"Unknown ({pid})"

    def _get_linux_process_for_port(self, port: int, protocol: str) -> Dict[str, str]:
        """Get process information for a port on Linux."""
        try:
            # Use lsof to find process
            result = subprocess.run(
                ["lsof", f"-i{protocol}:{port}"],
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode == 0:
                output = result.stdout

                # Parse lsof output
                for line in output.splitlines():
                    if "LISTEN" in line or protocol == "udp":
                        parts = line.split()
                        if len(parts) >= 2:
                            return {
                                'name': parts[0],
                                'pid': parts[1]
                            }

            return {'name': 'Unknown', 'pid': ''}

        except Exception:
            return {'name': 'Unknown', 'pid': ''}