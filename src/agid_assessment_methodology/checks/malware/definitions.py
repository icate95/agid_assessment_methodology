"""
Antivirus definitions update check.

This module implements checks to verify that antivirus software has
up-to-date virus definitions and scanning configurations.
"""

import logging
import subprocess
import json
import platform
import re
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime, timedelta

from agid_assessment_methodology.checks.base import BaseCheck, CheckResult, CheckStatus
from agid_assessment_methodology.utils.helpers import run_command, is_windows, is_linux

logger = logging.getLogger(__name__)

class DefinitionsCheck(BaseCheck):
    """Check for antivirus definitions updates and scanning configuration."""
    def __init__(self):
        super().__init__()
        self.id = "antivirus_definitions"
        self.name = "Antivirus Definitions"
        self.description = "Verify antivirus definitions are up-to-date and scanning is configured"
        self.category = "malware"
        self.severity = "high"
        self.supported_os = ["windows", "linux", "macos"]

    def execute(self, context: Dict[str, Any]) -> CheckResult:
        """
        Execute the antivirus definitions check.

        Args:
            context: Execution context containing OS info and other details

        Returns:
            CheckResult with the antivirus definitions status
        """
        try:
            os_type = context.get('os_type', platform.system().lower())

            if os_type == 'windows':
                return self._check_windows_definitions()
            elif os_type == 'linux':
                return self._check_linux_definitions()
            elif os_type == 'darwin':  # macOS
                return self._check_macos_definitions()
            else:
                return self._create_error_result(f"Unsupported OS: {os_type}")

        except Exception as e:
            logger.error(f"Error in antivirus definitions check: {str(e)}")
            return self._create_error_result(str(e))

    def _check_windows_definitions(self) -> CheckResult:
        """Check Windows antivirus definitions status."""
        results = {
            'defender_definitions': {},
            'third_party_definitions': [],
            'scheduled_scans': {},
            'real_time_protection': False,
            'last_scan': None
        }

        try:
            # Check Windows Defender definitions
            defender_info = self._check_windows_defender_definitions()
            results['defender_definitions'] = defender_info

            # Check for third-party antivirus definitions
            third_party_info = self._check_third_party_definitions_windows()
            results['third_party_definitions'] = third_party_info

            # Check scheduled scan configuration
            scan_config = self._check_windows_scan_configuration()
            results['scheduled_scans'] = scan_config

            # Check real-time protection status
            rt_protection = self._check_windows_realtime_protection()
            results['real_time_protection'] = rt_protection

            # Check last scan information
            last_scan = self._check_windows_last_scan()
            results['last_scan'] = last_scan

            # Determine overall status
            status, message = self._assess_windows_status(results)

        except Exception as e:
            logger.error(f"Error checking Windows definitions: {str(e)}")
            status = "error"
            message = f"Error checking Windows antivirus definitions: {str(e)}"

        return CheckResult(
            status=CheckStatus(status),
            message=message,
            details=results,
            recommendations=self._get_windows_recommendations(results)
        )

    def _check_windows_defender_definitions(self) -> Dict[str, Any]:
        """Check Windows Defender definitions status."""
        try:
            ps_command = """
            Get-MpComputerStatus | Select-Object -Property 
                AntivirusSignatureLastUpdated,
                AntivirusSignatureVersion,
                AntivirusSignatureAge,
                AntispywareSignatureLastUpdated,
                AntispywareSignatureVersion,
                AntispywareSignatureAge,
                NISSignatureLastUpdated,
                NISSignatureVersion,
                NISSignatureAge
            | ConvertTo-Json
            """

            result = subprocess.run(
                ["powershell", "-Command", ps_command],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0 and result.stdout.strip():
                definitions_data = json.loads(result.stdout)

                # Parse definition information
                def_info = {
                    'antivirus_last_updated': definitions_data.get('AntivirusSignatureLastUpdated'),
                    'antivirus_version': definitions_data.get('AntivirusSignatureVersion'),
                    'antivirus_age_days': definitions_data.get('AntivirusSignatureAge'),
                    'antispyware_last_updated': definitions_data.get('AntispywareSignatureLastUpdated'),
                    'antispyware_version': definitions_data.get('AntispywareSignatureVersion'),
                    'antispyware_age_days': definitions_data.get('AntispywareSignatureAge'),
                    'nis_last_updated': definitions_data.get('NISSignatureLastUpdated'),
                    'nis_version': definitions_data.get('NISSignatureVersion'),
                    'nis_age_days': definitions_data.get('NISSignatureAge')
                }

                # Determine if definitions are current
                max_age = max(
                    def_info.get('antivirus_age_days', 0) or 0,
                    def_info.get('antispyware_age_days', 0) or 0,
                    def_info.get('nis_age_days', 0) or 0
                )

                def_info['max_age_days'] = max_age
                def_info['definitions_current'] = max_age <= 7  # Consider current if updated within 7 days
                def_info['definitions_outdated'] = max_age > 30  # Consider outdated if older than 30 days

                return def_info

        except Exception as e:
            logger.error(f"Error checking Windows Defender definitions: {str(e)}")
            return {'error': str(e)}

        return {'error': 'Unable to check Windows Defender definitions'}

    def _check_third_party_definitions_windows(self) -> List[Dict[str, Any]]:
        """Check third-party antivirus definitions on Windows."""
        third_party_av = []

        try:
            # Check WMI for AntiVirusProduct information
            wmi_command = """
            Get-WmiObject -Namespace root\\SecurityCenter2 -Class AntiVirusProduct |
            Select-Object displayName, productState, pathToSignedProductExe, timestamp |
            ConvertTo-Json
            """

            result = subprocess.run(
                ["powershell", "-Command", wmi_command],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0 and result.stdout.strip():
                av_products = json.loads(result.stdout)

                if isinstance(av_products, dict):
                    av_products = [av_products]

                for product in av_products:
                    # Skip Windows Defender as it's checked separately
                    if 'defender' in product.get('displayName', '').lower():
                        continue

                    product_state = product.get('productState', 0)
                    if isinstance(product_state, str):
                        product_state = int(product_state, 16) if product_state.startswith('0x') else int(product_state)

                    # Decode product state
                    enabled = bool(product_state & 0x1000)
                    updated = bool(product_state & 0x10)

                    av_info = {
                        'name': product.get('displayName', 'Unknown'),
                        'enabled': enabled,
                        'definitions_updated': updated,
                        'path': product.get('pathToSignedProductExe', ''),
                        'timestamp': product.get('timestamp', '')
                    }

                    third_party_av.append(av_info)

        except Exception as e:
            logger.error(f"Error checking third-party AV definitions: {str(e)}")

        return third_party_av

    def _check_windows_scan_configuration(self) -> Dict[str, Any]:
        """Check Windows Defender scan configuration."""
        try:
            ps_command = """
            Get-MpPreference | Select-Object -Property 
                ScanScheduleDay,
                ScanScheduleTime,
                ScanScheduleQuickScanTime,
                SignatureScheduleDay,
                SignatureScheduleTime,
                CheckForSignaturesBeforeRunningScan
            | ConvertTo-Json
            """

            result = subprocess.run(
                ["powershell", "-Command", ps_command],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode == 0 and result.stdout.strip():
                scan_config = json.loads(result.stdout)

                return {
                    'full_scan_day': scan_config.get('ScanScheduleDay'),
                    'full_scan_time': scan_config.get('ScanScheduleTime'),
                    'quick_scan_time': scan_config.get('ScanScheduleQuickScanTime'),
                    'signature_update_day': scan_config.get('SignatureScheduleDay'),
                    'signature_update_time': scan_config.get('SignatureScheduleTime'),
                    'check_signatures_before_scan': scan_config.get('CheckForSignaturesBeforeRunningScan'),
                    'scheduled_scans_configured': bool(scan_config.get('ScanScheduleDay') or scan_config.get('ScanScheduleQuickScanTime'))
                }

        except Exception as e:
            logger.error(f"Error checking scan configuration: {str(e)}")
            return {'error': str(e)}

        return {'scheduled_scans_configured': False}

    def _check_windows_realtime_protection(self) -> bool:
        """Check if real-time protection is enabled."""
        try:
            ps_command = """
            Get-MpComputerStatus | Select-Object -Property RealTimeProtectionEnabled | ConvertTo-Json
            """

            result = subprocess.run(
                ["powershell", "-Command", ps_command],
                capture_output=True,
                text=True,
                timeout=15
            )

            if result.returncode == 0 and result.stdout.strip():
                status_data = json.loads(result.stdout)
                return status_data.get('RealTimeProtectionEnabled', False)

        except Exception as e:
            logger.error(f"Error checking real-time protection: {str(e)}")

        return False

    def _check_windows_last_scan(self) -> Optional[Dict[str, Any]]:
        """Check last scan information."""
        try:
            ps_command = """
            Get-MpComputerStatus | Select-Object -Property 
                QuickScanStartTime,
                QuickScanEndTime,
                FullScanStartTime,
                FullScanEndTime,
                LastQuickScanSource,
                LastFullScanSource
            | ConvertTo-Json
            """

            result = subprocess.run(
                ["powershell", "-Command", ps_command],
                capture_output=True,
                text=True,
                timeout=15
            )

            if result.returncode == 0 and result.stdout.strip():
                scan_data = json.loads(result.stdout)

                return {
                    'quick_scan_start': scan_data.get('QuickScanStartTime'),
                    'quick_scan_end': scan_data.get('QuickScanEndTime'),
                    'full_scan_start': scan_data.get('FullScanStartTime'),
                    'full_scan_end': scan_data.get('FullScanEndTime'),
                    'last_quick_scan_source': scan_data.get('LastQuickScanSource'),
                    'last_full_scan_source': scan_data.get('LastFullScanSource')
                }

        except Exception as e:
            logger.error(f"Error checking last scan info: {str(e)}")

        return None

    def _check_linux_definitions(self) -> CheckResult:
        """Check Linux antivirus definitions status."""
        results = {
            'clamav_definitions': {},
            'other_av_definitions': [],
            'scheduled_scans': {},
            'daemon_status': None
        }

        try:
            # Check ClamAV definitions
            clamav_info = self._check_clamav_definitions()
            results['clamav_definitions'] = clamav_info

            # Check for other antivirus solutions
            other_av = self._check_other_linux_av_definitions()
            results['other_av_definitions'] = other_av

            # Check scheduled scans
            scan_config = self._check_linux_scan_configuration()
            results['scheduled_scans'] = scan_config

            # Determine overall status
            status, message = self._assess_linux_status(results)

        except Exception as e:
            logger.error(f"Error checking Linux definitions: {str(e)}")
            status = "error"
            message = f"Error checking Linux antivirus definitions: {str(e)}"

        return CheckResult(
            status=CheckStatus(status),
            message=message,
            details=results,
            recommendations=self._get_linux_recommendations(results)
        )

    def _check_clamav_definitions(self) -> Dict[str, Any]:
        """Check ClamAV definitions status."""
        try:
            # Check if ClamAV is installed
            result = subprocess.run(
                ["which", "clamscan"],
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode != 0:
                return {'installed': False}

            # Get ClamAV version and database info
            version_result = subprocess.run(
                ["clamscan", "--version"],
                capture_output=True,
                text=True,
                timeout=10
            )

            definitions_info = {'installed': True}

            if version_result.returncode == 0:
                # Parse version information
                version_output = version_result.stdout
                version_match = re.search(r'ClamAV (\d+\.\d+\.\d+)', version_output)
                if version_match:
                    definitions_info['clamav_version'] = version_match.group(1)

                # Extract database information
                db_match = re.search(r'(\d+)/(\d+)/(\d+)', version_output)
                if db_match:
                    definitions_info['database_date'] = f"{db_match.group(3)}-{db_match.group(1)}-{db_match.group(2)}"

            # Check database freshness using freshclam
            try:
                freshclam_result = subprocess.run(
                    ["freshclam", "--check"],
                    capture_output=True,
                    text=True,
                    timeout=15
                )

                if freshclam_result.returncode == 0:
                    definitions_info['database_current'] = True
                else:
                    definitions_info['database_current'] = False
                    definitions_info['update_needed'] = True

            except FileNotFoundError:
                definitions_info['freshclam_available'] = False

            # Check database file timestamps
            db_paths = ['/var/lib/clamav/', '/usr/local/share/clamav/', '/opt/clamav/share/clamav/']
            for db_path in db_paths:
                try:
                    import os
                    if os.path.exists(db_path):
                        # Check main.cvd or daily.cvd timestamp
                        for db_file in ['main.cvd', 'daily.cvd', 'bytecode.cvd']:
                            db_file_path = os.path.join(db_path, db_file)
                            if os.path.exists(db_file_path):
                                mtime = os.path.getmtime(db_file_path)
                                file_age_days = (datetime.now().timestamp() - mtime) / (24 * 3600)
                                definitions_info[f'{db_file}_age_days'] = round(file_age_days, 1)

                                if 'oldest_definition_days' not in definitions_info:
                                    definitions_info['oldest_definition_days'] = file_age_days
                                else:
                                    definitions_info['oldest_definition_days'] = max(
                                        definitions_info['oldest_definition_days'], file_age_days
                                    )
                        break
                except Exception as e:
                    logger.debug(f"Error checking database timestamps in {db_path}: {e}")

            return definitions_info

        except Exception as e:
            logger.error(f"Error checking ClamAV definitions: {str(e)}")
            return {'installed': False, 'error': str(e)}

    def _check_other_linux_av_definitions(self) -> List[Dict[str, Any]]:
        """Check other Linux antivirus definitions."""
        other_av = []

        # Common Linux AV solutions
        av_solutions = {
            'sophos': {
                'check_cmd': ['savscan', '--version'],
                'update_cmd': ['savupdate', '--status']
            },
            'eset': {
                'check_cmd': ['/opt/eset/esets/bin/esets_scan', '--version'],
                'update_cmd': ['/opt/eset/esets/bin/esets_update', '--print-settings']
            },
            'bitdefender': {
                'check_cmd': ['bdscan', '--version'],
                'update_cmd': ['bdscan', '--update-check']
            }
        }

        for av_name, commands in av_solutions.items():
            try:
                # Check if AV is installed
                check_result = subprocess.run(
                    commands['check_cmd'],
                    capture_output=True,
                    text=True,
                    timeout=10
                )

                if check_result.returncode == 0:
                    av_info = {
                        'name': av_name.capitalize(),
                        'installed': True,
                        'version_info': check_result.stdout.strip()
                    }

                    # Check update status if command available
                    if 'update_cmd' in commands:
                        try:
                            update_result = subprocess.run(
                                commands['update_cmd'],
                                capture_output=True,
                                text=True,
                                timeout=15
                            )

                            if update_result.returncode == 0:
                                av_info['update_status'] = update_result.stdout.strip()
                                av_info['definitions_current'] = 'up-to-date' in update_result.stdout.lower()
                        except Exception:
                            av_info['update_status'] = 'Unable to check'

                    other_av.append(av_info)

            except FileNotFoundError:
                continue
            except Exception as e:
                logger.debug(f"Error checking {av_name}: {str(e)}")

        return other_av

    def _check_linux_scan_configuration(self) -> Dict[str, Any]:
        """Check Linux scan configuration (cron jobs, systemd timers)."""
        scan_config = {
            'cron_scans': [],
            'systemd_timers': [],
            'scheduled_scans_found': False
        }

        try:
            # Check cron jobs for scanning
            cron_result = subprocess.run(
                ["crontab", "-l"],
                capture_output=True,
                text=True,
                timeout=10
            )

            if cron_result.returncode == 0:
                cron_lines = cron_result.stdout.split('\n')
                for line in cron_lines:
                    if any(keyword in line.lower() for keyword in ['clamscan', 'scan', 'antivirus']):
                        scan_config['cron_scans'].append(line.strip())
                        scan_config['scheduled_scans_found'] = True

            # Check systemd timers
            timer_result = subprocess.run(
                ["systemctl", "list-timers", "--all"],
                capture_output=True,
                text=True,
                timeout=10
            )

            if timer_result.returncode == 0:
                timer_lines = timer_result.stdout.split('\n')
                for line in timer_lines:
                    if any(keyword in line.lower() for keyword in ['clam', 'scan', 'antivirus']):
                        scan_config['systemd_timers'].append(line.strip())
                        scan_config['scheduled_scans_found'] = True

        except Exception as e:
            logger.error(f"Error checking scan configuration: {str(e)}")
            scan_config['error'] = str(e)

        return scan_config

    def _check_macos_definitions(self) -> CheckResult:
        """Check macOS antivirus definitions status."""
        results = {
            'xprotect_definitions': {},
            'third_party_definitions': [],
            'system_updates': {}
        }

        try:
            # Check XProtect definitions
            xprotect_info = self._check_xprotect_definitions()
            results['xprotect_definitions'] = xprotect_info

            # Check third-party antivirus definitions
            third_party_info = self._check_third_party_macos_definitions()
            results['third_party_definitions'] = third_party_info

            # Check system updates (which include security updates)
            system_updates = self._check_macos_system_updates()
            results['system_updates'] = system_updates

            # Determine overall status
            status, message = self._assess_macos_status(results)

        except Exception as e:
            logger.error(f"Error checking macOS definitions: {str(e)}")
            status = "error"
            message = f"Error checking macOS antivirus definitions: {str(e)}"

        return CheckResult(
            status=CheckStatus(status),
            message=message,
            details=results,
            recommendations=self._get_macos_recommendations(results)
        )

    def _check_xprotect_definitions(self) -> Dict[str, Any]:
        """Check XProtect definitions status."""
        try:
            # Check XProtect version and last update
            result = subprocess.run(
                ["system_profiler", "SPInstallHistoryDataType"],
                capture_output=True,
                text=True,
                timeout=30
            )

            xprotect_info = {'detected': False}

            if result.returncode == 0:
                # Look for XProtect updates in install history
                lines = result.stdout.split('\n')
                xprotect_updates = []

                for i, line in enumerate(lines):
                    if 'XProtect' in line or 'Gatekeeper' in line:
                        xprotect_info['detected'] = True
                        # Try to extract date from following lines
                        for j in range(i, min(i+10, len(lines))):
                            if 'Install Date:' in lines[j]:
                                date_match = re.search(r'Install Date: (.+)', lines[j])
                                if date_match:
                                    xprotect_updates.append({
                                        'name': line.strip(),
                                        'install_date': date_match.group(1).strip()
                                    })
                                break

                if xprotect_updates:
                    xprotect_info['recent_updates'] = xprotect_updates
                    # Check if latest update is recent (within 30 days)
                    latest_update = xprotect_updates[0]['install_date']
                    try:
                        update_date = datetime.strptime(latest_update, '%m/%d/%y')
                        days_since_update = (datetime.now() - update_date).days
                        xprotect_info['days_since_last_update'] = days_since_update
                        xprotect_info['definitions_current'] = days_since_update <= 30
                    except Exception as e:
                        logger.debug(f"Error parsing XProtect update date: {e}")

            # Check XProtect status
            status_result = subprocess.run(
                ["spctl", "--status"],
                capture_output=True,
                text=True,
                timeout=10
            )

            if status_result.returncode == 0:
                xprotect_info['gatekeeper_enabled'] = "assessments enabled" in status_result.stdout

            return xprotect_info

        except Exception as e:
            logger.error(f"Error checking XProtect definitions: {str(e)}")
            return {'detected': False, 'error': str(e)}

    def _check_third_party_macos_definitions(self) -> List[Dict[str, Any]]:
        """Check third-party antivirus definitions on macOS."""
        third_party_av = []

        # Common macOS antivirus applications and their definition check methods
        av_apps = {
            'Norton Security': {
                'app_path': '/Applications/Norton Security.app',
                'process_name': 'Norton Security'
            },
            'Bitdefender Antivirus': {
                'app_path': '/Applications/Bitdefender Antivirus for Mac.app',
                'process_name': 'Bitdefender'
            },
            'Kaspersky Internet Security': {
                'app_path': '/Applications/Kaspersky Internet Security for Mac.app',
                'process_name': 'Kaspersky'
            },
            'Sophos Home': {
                'app_path': '/Applications/Sophos Home.app',
                'process_name': 'Sophos'
            },
            'Avast Security': {
                'app_path': '/Applications/Avast.app',
                'process_name': 'Avast'
            }
        }

        for av_name, av_config in av_apps.items():
            try:
                import os
                app_path = av_config['app_path']

                if os.path.exists(app_path):
                    av_info = {
                        'name': av_name,
                        'installed': True,
                        'app_path': app_path
                    }

                    # Check if the application is running
                    proc_result = subprocess.run(
                        ["pgrep", "-f", av_config['process_name']],
                        capture_output=True,
                        text=True,
                        timeout=5
                    )

                    av_info['running'] = proc_result.returncode == 0

                    # Try to get version info
                    try:
                        version_result = subprocess.run(
                            ["defaults", "read", f"{app_path}/Contents/Info.plist", "CFBundleShortVersionString"],
                            capture_output=True,
                            text=True,
                            timeout=10
                        )

                        if version_result.returncode == 0:
                            av_info['version'] = version_result.stdout.strip()
                    except Exception:
                        pass

                    third_party_av.append(av_info)

            except Exception as e:
                logger.debug(f"Error checking {av_name}: {str(e)}")

        return third_party_av

    def _check_macos_system_updates(self) -> Dict[str, Any]:
        """Check macOS system updates (includes security updates)."""
        try:
            # Check for available updates
            result = subprocess.run(
                ["softwareupdate", "--list"],
                capture_output=True,
                text=True,
                timeout=30
            )

            update_info = {
                'updates_available': False,
                'security_updates': [],
                'other_updates': []
            }

            if result.returncode == 0:
                if "No new software available" in result.stdout:
                    update_info['updates_available'] = False
                else:
                    update_info['updates_available'] = True

                    # Parse available updates
                    lines = result.stdout.split('\n')
                    for line in lines:
                        if line.strip().startswith('*') or line.strip().startswith('-'):
                            update_name = line.strip().lstrip('*-').strip()
                            if any(keyword in update_name.lower() for keyword in ['security', 'xprotect', 'gatekeeper']):
                                update_info['security_updates'].append(update_name)
                            else:
                                update_info['other_updates'].append(update_name)

            # Check last update check time
            try:
                prefs_result = subprocess.run(
                    ["defaults", "read", "/Library/Preferences/com.apple.SoftwareUpdate", "LastSuccessfulDate"],
                    capture_output=True,
                    text=True,
                    timeout=10
                )

                if prefs_result.returncode == 0:
                    update_info['last_check_date'] = prefs_result.stdout.strip()
            except Exception:
                pass

            return update_info

        except Exception as e:
            logger.error(f"Error checking macOS system updates: {str(e)}")
            return {'error': str(e)}

    def _assess_windows_status(self, results: Dict[str, Any]) -> Tuple[str, str]:
        """Assess Windows antivirus definitions status."""
        defender_defs = results.get('defender_definitions', {})
        third_party_defs = results.get('third_party_definitions', [])

        issues = []

        # Check Windows Defender definitions
        if 'error' not in defender_defs:
            max_age = defender_defs.get('max_age_days', 0)
            if max_age > 30:
                issues.append(f"Windows Defender definitions are {max_age} days old")
            elif max_age > 7:
                issues.append(f"Windows Defender definitions are {max_age} days old (should update weekly)")

        # Check third-party definitions
        for av in third_party_defs:
            if av.get('enabled') and not av.get('definitions_updated'):
                issues.append(f"{av['name']} definitions may be outdated")

        # Check real-time protection
        if not results.get('real_time_protection'):
            issues.append("Real-time protection is disabled")

        # Check scheduled scans
        scan_config = results.get('scheduled_scans', {})
        if not scan_config.get('scheduled_scans_configured'):
            issues.append("No scheduled scans configured")

        if not issues:
            return 'pass', 'Antivirus definitions and configuration are current'
        elif len(issues) == 1 and 'should update weekly' in issues[0]:
            return 'warning', f"Minor issue: {issues[0]}"
        else:
            return 'fail', f"Found {len(issues)} definition/configuration issues"

    def _assess_linux_status(self, results: Dict[str, Any]) -> Tuple[str, str]:
        """Assess Linux antivirus definitions status."""
        clamav_defs = results.get('clamav_definitions', {})
        other_av_defs = results.get('other_av_definitions', [])

        issues = []

        # Check ClamAV
        if clamav_defs.get('installed'):
            if clamav_defs.get('update_needed'):
                issues.append("ClamAV definitions need updating")

            oldest_days = clamav_defs.get('oldest_definition_days')
            if oldest_days and oldest_days > 7:
                issues.append(f"ClamAV definitions are {oldest_days:.1f} days old")
        else:
            # Check if any other AV is installed
            if not other_av_defs:
                issues.append("No antivirus software detected")

        # Check other antivirus definitions
        for av in other_av_defs:
            if not av.get('definitions_current', True):
                issues.append(f"{av['name']} definitions may be outdated")

        # Check scheduled scans
        scan_config = results.get('scheduled_scans', {})
        if not scan_config.get('scheduled_scans_found'):
            issues.append("No scheduled antivirus scans found")

        if not issues:
            return 'pass', 'Antivirus definitions appear current'
        elif len(issues) == 1 and 'No scheduled' in issues[0]:
            return 'warning', f"Configuration issue: {issues[0]}"
        else:
            return 'fail', f"Found {len(issues)} definition/configuration issues"

    def _assess_macos_status(self, results: Dict[str, Any]) -> Tuple[str, str]:
        """Assess macOS antivirus definitions status."""
        xprotect_defs = results.get('xprotect_definitions', {})
        system_updates = results.get('system_updates', {})

        issues = []

        # Check XProtect
        if not xprotect_defs.get('detected'):
            issues.append("XProtect system not detected or configured")
        else:
            days_since_update = xprotect_defs.get('days_since_last_update')
            if days_since_update and days_since_update > 30:
                issues.append(f"XProtect last updated {days_since_update} days ago")

        # Check system updates
        if system_updates.get('security_updates'):
            security_count = len(system_updates['security_updates'])
            issues.append(f"{security_count} security updates available")

        if not issues:
            return 'pass', 'macOS security definitions appear current'
        elif len(issues) == 1 and 'security updates available' in issues[0]:
            return 'warning', issues[0]
        else:
            return 'fail', f"Found {len(issues)} security definition issues"

    def _get_windows_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate Windows-specific recommendations."""
        recommendations = []

        defender_defs = results.get('defender_definitions', {})
        if 'error' not in defender_defs:
            max_age = defender_defs.get('max_age_days', 0)
            if max_age > 7:
                recommendations.append("Update Windows Defender definitions manually or check automatic update settings")

        if not results.get('real_time_protection'):
            recommendations.append("Enable Windows Defender real-time protection")

        scan_config = results.get('scheduled_scans', {})
        if not scan_config.get('scheduled_scans_configured'):
            recommendations.append("Configure scheduled antivirus scans (daily quick scan, weekly full scan)")

        third_party_defs = results.get('third_party_definitions', [])
        for av in third_party_defs:
            if av.get('enabled') and not av.get('definitions_updated'):
                recommendations.append(f"Update {av['name']} antivirus definitions")

        if not recommendations:
            recommendations.append("Antivirus definitions and configuration appear optimal")

        return recommendations

    def _get_linux_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate Linux-specific recommendations."""
        recommendations = []

        clamav_defs = results.get('clamav_definitions', {})
        if clamav_defs.get('installed'):
            if clamav_defs.get('update_needed'):
                recommendations.append("Update ClamAV definitions: sudo freshclam")

            oldest_days = clamav_defs.get('oldest_definition_days')
            if oldest_days and oldest_days > 7:
                recommendations.append("Set up automatic ClamAV definition updates")
        else:
            other_av_defs = results.get('other_av_definitions', [])
            if not other_av_defs:
                recommendations.append("Install antivirus software (e.g., ClamAV: sudo apt install clamav)")

        scan_config = results.get('scheduled_scans', {})
        if not scan_config.get('scheduled_scans_found'):
            recommendations.append("Schedule regular antivirus scans using cron or systemd timers")

        for av in results.get('other_av_definitions', []):
            if not av.get('definitions_current', True):
                recommendations.append(f"Update {av['name']} antivirus definitions")

        if not recommendations:
            recommendations.append("Consider setting up automated definition updates and scheduled scans")

        return recommendations

    def _get_macos_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate macOS-specific recommendations."""
        recommendations = []

        xprotect_defs = results.get('xprotect_definitions', {})
        if not xprotect_defs.get('detected'):
            recommendations.append("Ensure XProtect is enabled and functioning")
        else:
            days_since_update = xprotect_defs.get('days_since_last_update')
            if days_since_update and days_since_update > 30:
                recommendations.append("Check for macOS system updates to update XProtect definitions")

        system_updates = results.get('system_updates', {})
        if system_updates.get('security_updates'):
            recommendations.append("Install available security updates: System Preferences > Software Update")

        # Check if Gatekeeper is enabled
        if not xprotect_defs.get('gatekeeper_enabled'):
            recommendations.append("Enable Gatekeeper in System Preferences > Security & Privacy")

        third_party_av = results.get('third_party_definitions', [])
        if third_party_av:
            for av in third_party_av:
                if av.get('installed') and not av.get('running'):
                    recommendations.append(f"Start {av['name']} antivirus service")

        if not recommendations:
            recommendations.append("macOS security definitions appear current - enable automatic updates")

        return recommendations

    def _create_error_result(self, error_message: str) -> CheckResult:
        """Create an error result."""
        return CheckResult(
            status=CheckStatus.ERROR,
            message=error_message,
            details={"error": error_message}
        )